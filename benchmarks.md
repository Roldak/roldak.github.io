---
layout: default
title: Benchmarks
short_title: Benchmarks
---

{% include oopsla.md %}

This document will only present a few of the bechmarks:

 * macrobenchmarks - large and complex programs
 * microbenchmarks - small and focused benchmarks
 * bytecode size comparisons


## Macrobenchmarks

To evaluate the miniboxing plugin, we [implemented a mock-up of the Scala collections linked list](/example_linkedlist.html) and benchmarked the performance. The result: **1.5x-4x speedup just by adding the** `@miniboxed` **annotation**. And it's worth pointing out our mock-up included all the common patterns found in the library: `Builder`, `Numeric`, `Traversable`, `Seq`, closures, tuples etc.

The benchmark we ran is fitting a linear curve to a given set of points using the <a href="http://en.wikipedia.org/wiki/Least_squares" target="_blank"><em>Least Squares method</em></a>. Basically, we made a custom library and benchmarked this code:

{% highlight scala %}
  val xs: List[Double] = // list of x coordinates
  val ys: List[Double] = // list of y coordinates

  // list of (x,y) coordinates:
  val xys = xs.zip(ys)

  // intermediary sums:
  val sumx  = xs.sum
  val sumy  = ys.sum
  val sumxy = xys.map(mult).sum
  val sumsquare = xs.map(square).sum

  // slope and intercept approximation:
  val slope = (size * sumxy - sumx * sumy) / (size * sumsquare - sumx * sumx)
  val intercept = (sumy * sumsquare - sumx * sumxy) / (size * sumsquare - sumx * sumx)
{% endhighlight %}

### With infinite heap memory (no garbage collection overhead)

We ran this code with two versions of the linked list: one with the plugin activated and one with generic classes. The numbers were obtained on an i7 server machine with 32GB of RAM, and we made sure no garbage collections occured (`-Xmx16g`, `-Xms16g`):

<center><img width="90%" src="/graphs/linkedlist/linkedlist2.png"/></center>

This shows miniboxed linked lists are 1.5x to 2x faster than generic collections, despite the fact that linked lists are not contiguous, thus reducing the benefits of miniboxing. We have also tested specialization, but it ran out of memory and we were unable to get any garbage collection-free runs above 1500000 elements (we suspect this is due to bug <a href="https://issues.scala-lang.org/browse/SI-3585" target="_blank">SI-3585 Specialized class should not have duplicate fields</a>, but haven't examined in depth).

### With limited heap memory

We also wanted to test how miniboxing copes with garbage collection cycles compared to the generic library. To do so, we limited the heap size to 2G (`-Xmx2g`, `-Xms2g`, `-XX:+UseParallelGC`):

<center><img width="90%" src="/graphs/linkedlist/linkedlist3.png"/></center>

To summarize, on linked lists, we can expect **speedups between 1.5x and 4x**, despite the non-contiguous nature of the linked list.

The full description of this experiment is [available here](/example_linkedlist.html).

## Microbenchmarks

Another important benchmark is the `ArrayBuffer.reverse`. This is the most difficult benchmark to get right, since the
miniboxing transformation interacts with the Java Virtual Machine optimization heuristics and, if the transformation is
not done correctly, miniboxing can actually hurt performance (more details in the OOPSLA paper).

These are our current results:

<center><img width="90%" src="/graphs/speed-gen.png"/></center>

Where:

 * `generic` is the generic code
 * `miniboxing` is the code generated by our plugin
 * `specialization` is the code generated by the `@specialized` annotation in Scala
 * `monomorphic` is the code specialized by hand

After removing `generic`:

<center><img width="90%" src="/graphs/speed-spec.png"/></center>

## Bytecode Size

When comparing the total bytecode size for <a href="https://github.com/non/spire" target="_blank">spire</a> we see a 4.5x bytecode reduction:

<center><img width="90%" src="/graphs/size.png"/></center>

## More Benchmarks

The <a href="https://github.com/miniboxing/miniboxing-plugin/blob/wip/docs/2013-07-oopsla-preprint.pdf?raw=true" target="_blank">OOPSLA'13 paper</a> presents several other benchmarks:

 * performance microbenchmarks
   * on the HotSpot JVM with the Server compiler
   * on the HotSpot JVM with the Graal compiler
 * interpreter performance microbenchmarks
 * bytecode size
 * classloader overhead
   * performance impact
   * heap consumption

The <a href="https://github.com/miniboxing/miniboxing-plugin/blob/wip/docs/2014-04-miniboxing-scala-collections.pdf?raw=true" target="_blank">SCALA'14 paper</a> presents:

 * a high-level overview of patterns in Scala
 * benchmarks for a mock-up of the Scala collection linked list

## Conclusion

In short, miniboxed code:

 * is up to *22x faster* than generic code
 * it surpasses the performance of specialization
 * is marginally slower compared to monomorphic code, with an overhead of about 10%
